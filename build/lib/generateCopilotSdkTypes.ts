/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Generates `src/vs/sessions/services/copilotSdk/node/generated/sdkTypes.generated.ts`
 * from the `@github/copilot-sdk` type definitions.
 *
 * This creates a compile-time mirror of SDK types in the node layer so the host
 * and mapper can reference SDK shapes without importing `@github/copilot-sdk`
 * directly. The generated file contains only type declarations (interfaces and
 * type aliases) -- no runtime code.
 *
 * Run: `node build/lib/generateCopilotSdkTypes.ts`
 * Or:  `npm run generate-sdk-types`
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT = path.resolve(__dirname, '..', '..');
const SDK_SESSION_EVENTS = path.join(ROOT, 'node_modules/@github/copilot-sdk/dist/generated/session-events.d.ts');
const SDK_TYPES = path.join(ROOT, 'node_modules/@github/copilot-sdk/dist/types.d.ts');
const OUTPUT = path.join(ROOT, 'src/vs/sessions/services/copilotSdk/node/generated/sdkTypes.generated.ts');

function readSdkFile(filePath: string): string {
	if (!fs.existsSync(filePath)) {
		throw new Error(`SDK type file not found: ${filePath}\nMake sure @github/copilot-sdk is installed.`);
	}
	return fs.readFileSync(filePath, 'utf-8');
}

/**
 * Extract the full `SessionEvent` discriminated union from the generated
 * session-events.d.ts. We re-emit it as `SdkSessionEvent`.
 */
function extractSessionEventUnion(source: string): string {
	// The file exports a single `export type SessionEvent = { ... } | { ... } | ...;`
	const match = source.match(/export type SessionEvent\s*=\s*([\s\S]+);$/m);
	if (!match) {
		throw new Error('Could not extract SessionEvent union from session-events.d.ts');
	}
	return match[1].trim();
}

/**
 * Extract a named interface from types.d.ts.
 */
function extractInterface(source: string, name: string): string | undefined {
	// Match `export interface Name { ... }` -- handles nested braces
	const startPattern = new RegExp(`export interface ${name}\\s*\\{`);
	const startMatch = startPattern.exec(source);
	if (!startMatch) {
		return undefined;
	}
	let depth = 1;
	let i = startMatch.index + startMatch[0].length;
	while (i < source.length && depth > 0) {
		if (source[i] === '{') { depth++; }
		if (source[i] === '}') { depth--; }
		i++;
	}
	const body = source.slice(startMatch.index + startMatch[0].length, i - 1);
	return body;
}

/**
 * Extract a named type alias from types.d.ts.
 */
function extractTypeAlias(source: string, name: string): string | undefined {
	const pattern = new RegExp(`export type ${name}\\s*=\\s*([^;]+);`);
	const match = pattern.exec(source);
	return match ? match[1].trim() : undefined;
}

function generate(): string {
	const sessionEventsSource = readSdkFile(SDK_SESSION_EVENTS);
	const typesSource = readSdkFile(SDK_TYPES);

	const sessionEventUnion = extractSessionEventUnion(sessionEventsSource);

	// Extract types from types.d.ts
	const modelCapabilities = extractInterface(typesSource, 'ModelCapabilities');
	const modelPolicy = extractInterface(typesSource, 'ModelPolicy');
	const modelBilling = extractInterface(typesSource, 'ModelBilling');
	const modelInfo = extractInterface(typesSource, 'ModelInfo');
	const sessionMetadata = extractInterface(typesSource, 'SessionMetadata');
	const getStatusResponse = extractInterface(typesSource, 'GetStatusResponse');
	const getAuthStatusResponse = extractInterface(typesSource, 'GetAuthStatusResponse');
	const sessionLifecycleEvent = extractInterface(typesSource, 'SessionLifecycleEvent');
	const reasoningEffort = extractTypeAlias(typesSource, 'ReasoningEffort');
	const sessionLifecycleEventType = extractTypeAlias(typesSource, 'SessionLifecycleEventType');

	const lines: string[] = [];
	const emit = (line: string = '') => lines.push(line);

	emit('/*---------------------------------------------------------------------------------------------');
	emit(' *  Copyright (c) Microsoft Corporation. All rights reserved.');
	emit(' *  Licensed under the MIT License. See License.txt in the project root for license information.');
	emit(' *--------------------------------------------------------------------------------------------*/');
	emit();
	emit('/* eslint-disable local/code-no-unexternalized-strings */');
	emit();
	emit('/**');
	emit(' * AUTO-GENERATED from @github/copilot-sdk -- DO NOT EDIT MANUALLY');
	emit(' *');
	emit(' * Generated by: build/lib/generateCopilotSdkTypes.ts');
	emit(` * Generated at: ${new Date().toISOString()}`);
	emit(' *');
	emit(' * To regenerate: npm run generate-sdk-types');
	emit(' */');
	emit();

	// SessionEvent discriminated union
	emit('// #region Session Events');
	emit();
	emit('/**');
	emit(' * Mirror of the SDK\'s discriminated `SessionEvent` union.');
	emit(' * Each variant has a `type` discriminant and a typed `data` payload.');
	emit(' */');
	emit(`export type SdkSessionEvent = ${sessionEventUnion};`);
	emit();
	emit('/** Union of all SDK session event type strings. */');
	emit('export type SdkSessionEventType = SdkSessionEvent[\'type\'];');
	emit();
	emit('/** Extract the event payload for a specific event type. */');
	emit('export type SdkSessionEventPayload<T extends SdkSessionEventType> = Extract<SdkSessionEvent, { type: T }>;');
	emit();
	emit('// #endregion');
	emit();

	// Model types
	emit('// #region Model Types');
	emit();

	if (reasoningEffort) {
		emit(`export type SdkReasoningEffort = ${reasoningEffort};`);
		emit();
	}

	if (modelCapabilities) {
		emit('export interface SdkModelCapabilities {');
		emit(modelCapabilities);
		emit('}');
		emit();
	}

	if (modelPolicy) {
		emit('export interface SdkModelPolicy {');
		emit(modelPolicy);
		emit('}');
		emit();
	}

	if (modelBilling) {
		emit('export interface SdkModelBilling {');
		emit(modelBilling);
		emit('}');
		emit();
	}

	if (modelInfo) {
		emit('export interface SdkModelInfo {');
		emit(modelInfo);
		emit('}');
		emit();
	}

	emit('// #endregion');
	emit();

	// Session Metadata
	emit('// #region Session Metadata');
	emit();

	if (sessionMetadata) {
		emit('export interface SdkSessionMetadata {');
		emit(sessionMetadata);
		emit('}');
		emit();
	}

	emit('// #endregion');
	emit();

	// Status / Auth
	emit('// #region Status & Auth');
	emit();

	if (getStatusResponse) {
		emit('export interface SdkGetStatusResponse {');
		emit(getStatusResponse);
		emit('}');
		emit();
	}

	if (getAuthStatusResponse) {
		emit('export interface SdkGetAuthStatusResponse {');
		emit(getAuthStatusResponse);
		emit('}');
		emit();
	}

	emit('// #endregion');
	emit();

	// Lifecycle events
	emit('// #region Lifecycle Events');
	emit();

	if (sessionLifecycleEventType) {
		emit(`export type SdkSessionLifecycleEventType = ${sessionLifecycleEventType};`);
		emit();
	}

	if (sessionLifecycleEvent) {
		emit('export interface SdkSessionLifecycleEvent {');
		emit(sessionLifecycleEvent);
		emit('}');
		emit();
	}

	emit('// #endregion');
	emit();

	// Post-process: replace references to SDK types that need the `Sdk` prefix.
	// The extracted interface bodies reference the original SDK type names.
	const typeReplacements: [RegExp, string][] = [
		[/\bModelCapabilities\b/g, 'SdkModelCapabilities'],
		[/\bModelPolicy\b/g, 'SdkModelPolicy'],
		[/\bModelBilling\b/g, 'SdkModelBilling'],
		[/\bReasoningEffort\b/g, 'SdkReasoningEffort'],
		[/\bSessionLifecycleEventType\b/g, 'SdkSessionLifecycleEventType'],
	];

	let result = lines.join('\n');
	for (const [pattern, replacement] of typeReplacements) {
		// Only replace in non-declaration positions (skip `export type SdkFoo = ...` lines)
		result = result.replace(pattern, (match, offset: number) => {
			// Don't replace if this IS the declaration (preceded by `type Sdk` or `interface Sdk`)
			const before = result.slice(Math.max(0, offset - 30), offset);
			if (before.includes(`type ${replacement}`) || before.includes(`interface ${replacement}`)) {
				return match;
			}
			return replacement;
		});
	}

	return result;
}

// --- Main ---

const output = generate();
const outputDir = path.dirname(OUTPUT);
if (!fs.existsSync(outputDir)) {
	fs.mkdirSync(outputDir, { recursive: true });
}
fs.writeFileSync(OUTPUT, output, 'utf-8');
console.log(`Generated: ${path.relative(ROOT, OUTPUT)}`);
